#pragma kernel CSMain
#pragma kernel CSDirections
#pragma kernel CSPoints
#include "../DrawUtils.cginc"

float4 _Time;

float3 Start, End;
RWTexture2D<float4> Output;

float4 Color;

struct Direction
{
    float3 Start, End;
};

StructuredBuffer<Direction> Directions;
uint DirectionsCount;

struct Point
{
    float2 Pos;
};

RWStructuredBuffer<Point> Points;
uint PointsCount;
float PointSpacing;

StructuredBuffer<float3> TransformArray;
int TransformArrayCount;

StructuredBuffer<float3> TransformList;
int TransformListCount;

[numthreads(1,1,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Output.GetDimensions(width, height);
    const uint2 texSize = uint2(width, height);
    DrawCircle(Output, texSize, Start.xy, 10, float4(1, 0, 0, 1));
    DrawCircle(Output, texSize, End.xy, 7, float4(1, 0, 0, 1));
    DrawLine(Output, texSize, Start.xy, End.xy, float4(1, 0, 0, 1));


    for (int i = 0; i < TransformArrayCount; i++)
    {
        float3 pos = TransformArray[i];
        DrawCircle(Output, texSize, pos.xy, 5, float4(1, 1, 0, 1));
    }
    
    for (int i = 0; i < TransformListCount; i++)
    {
        float3 pos = TransformList[i];
        DrawCircle(Output, texSize, pos.xy, 5, float4(1, 0, 1, 1));
    }
}

[numthreads(32,1,1)]
void CSPoints(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= PointsCount) return;
    uint width, height;
    Output.GetDimensions(width, height);
    const uint2 texSize = uint2(width, height);
    Point pt = Points[id.x];
    float4 col = Color;// + float4(0, 0, 1, .05);


    float closestDistance = 9999;
    float2 closestDir;
    uint closeCount;
    float pushFactor = 1;
    for (uint i = 0; i < PointsCount; i++)
    {
        if (i == id.x) continue;
        Point other = Points[i];
        float2 dir = other.Pos - pt.Pos;
        float dist = length(dir);

        if (closestDistance < PointSpacing)
            closeCount += 1;
        if (dist < closestDistance)
        {
            closestDistance = dist;
            closestDir = dir;
        }
    }
    
    for (int i = 0; i < TransformArrayCount; i++)
    {
        float3 pos = TransformArray[i];
        float2 dir = pos - pt.Pos;
        float dist = length(dir);

        if (closestDistance < PointSpacing)
            closeCount += 1;
        if (dist*.5 < closestDistance)
        {
            closestDistance = dist;
            closestDir = dir;
            pushFactor = 3;
        }
    }


    if (closestDistance < PointSpacing)
    {
        pt.Pos -= closestDir / (closestDistance * 50) * _Time.w * (closeCount * PointSpacing) * pushFactor;
    }
    pt.Pos -= pt.Pos * _Time.w / max(PointSpacing * 10, .1);

    DrawCircle(Output, texSize, pt.Pos, 2, col);
    Points[id.x] = pt;
}


[numthreads(32,1,1)]
void CSDirections(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= DirectionsCount) return;
    uint width, height;
    Output.GetDimensions(width, height);
    const uint2 texSize = uint2(width, height);
    Direction dir = Directions[id.x];
    float4 col = float4(0, 1, length(dir.End - dir.Start), .05);
    DrawLine(Output, texSize, dir.Start.xy, dir.End.xy, col);
    DrawCircle(Output, texSize, dir.Start.xy, 5, col);
    DrawCircle(Output, texSize, dir.End.xy, 5, col);
}


#pragma kernel CSBlend
[numthreads(32, 32,1)]
void CSBlend(uint3 id : SV_DispatchThreadID)
{
    Output[id.xy] = lerp(Output[id.xy], 0, _Time.w *1);
}
