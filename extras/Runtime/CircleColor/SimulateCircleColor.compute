#pragma kernel CSSimulate
#pragma kernel CSRenderEntities

struct Circle
{
    float3 Position;
    float Radius;
};

float2 WorldScale;
float4 _Time;
RWStructuredBuffer<Circle> Circles; 
RWTexture2D<float4> Result, DataTexture;


struct Entity
{
    float3 Position;
    float Energy;
};
RWStructuredBuffer<Entity> Entities;


struct ColorDot
{
    float3 Position;
    float4 Color;
    float Weight;
};

RWStructuredBuffer<ColorDot> Dots;


[numthreads(64,1,1)]
void CSSimulate(uint3 id : SV_DispatchThreadID)
{
    uint _;

    uint entCount;
    Entities.GetDimensions(entCount, _);
    if(id.x > entCount) return;
    
    uint circlesCount;
    Circles.GetDimensions(circlesCount, _);
    
    Entity entity = Entities[id.x];
    bool inCircleRadius = false; 
    for(uint k = 0; k < circlesCount; k++)
    {
        Circle circle = Circles[k];
        if(length(entity.Position - circle.Position) < circle.Radius)
        {
            inCircleRadius = true;
            entity.Energy += _Time.w;
            entity.Position = lerp(entity.Position, circle.Position, _Time.w * .1);
        }
    }
    if(!inCircleRadius)
    {
        entity.Energy -= _Time.w;
    }
    Entities[id.x] = entity;
}

[numthreads(32,1,1)]
void CSRenderEntities(uint3 id : SV_DispatchThreadID)
{
    uint _;
    uint entCount;
    Entities.GetDimensions(entCount, _);
    if(id.x > entCount) return;

    Entity entity = Entities[id.x];
    float2 uv = entity.Position.xy / WorldScale + .5;
    if(uv.x < 0 || uv.y < 0) return;
    
    uint width, height; 
    Result.GetDimensions(width, height);
    const uint2 pixel = uv * uint2(width, height);
    
    Result[pixel] = 1;
    DataTexture[pixel] = float4(1,0,0,0);
}

// [numthreads(32,32,1)]
// void CSRender(uint3 id : SV_DispatchThreadID)
// {
//     uint _;
//     uint width, height; 
//     Result.GetDimensions(width, height);
//     float2 uv = id.xy/float2(width,height);
//     float4 cur = Result[id.xy];
//     float2 world = (uv - .5) * WorldScale;
//
//     cur = lerp(cur, 0, _Time.w);;
//     
//     uint entCount;
//     Entities.GetDimensions(entCount, _);
//     for(uint i = id.x; i < entCount; i++)
//     {
//         Entity entity = Entities[i];
//         if(length(entity.Position.xy - world) < .01)
//         {
//             cur += 1 * _Time.w;// entity.Energy;
//         }
//     }
//
//     Result[id.xy] = cur;
// }