#pragma kernel CSSimulate
#pragma kernel CSRender

struct Circle
{
    float3 Position;
    float Radius;
};

float2 WorldScale;
float4 _Time;
RWStructuredBuffer<Circle> Circles; 
RWTexture2D<float4> Result;


struct Entity
{
    float3 Position;
    float Energy;
};
RWStructuredBuffer<Entity> Entities;


struct ColorDot
{
    float3 Position;
    float4 Color;
    float Weight;
};

RWStructuredBuffer<ColorDot> Dots;


[numthreads(64,1,1)]
void CSSimulate(uint3 id : SV_DispatchThreadID)
{
    uint _;

    uint entCount;
    Entities.GetDimensions(entCount, _);
    if(id.x > entCount) return;
    
    uint circlesCount;
    Circles.GetDimensions(circlesCount, _);
    
    Entity entity = Entities[id.x];
    bool inCircleRadius = false;
    for(uint k = 0; k < circlesCount; k++)
    {
        Circle circle = Circles[k];
        if(length(entity.Position - circle.Position) < circle.Radius)
        {
            inCircleRadius = true;
            entity.Energy += _Time.w;
            entity.Position = lerp(entity.Position, circle.Position, _Time.w * .1);
        }
    }
    if(!inCircleRadius)
    {
        entity.Energy -= _Time.w;
    }
    Entities[id.x] = entity;
}



[numthreads(8,8,1)]
void CSRender(uint3 id : SV_DispatchThreadID)
{
    uint _;
    uint width, height; 
    Result.GetDimensions(width, height);
    float2 uv = id.xy/float2(width,height);
    float4 cur = Result[id.xy];
    float2 world = (uv - .5) * WorldScale;

    cur = lerp(cur, 0, _Time.w);;
    
    uint entCount;
    Entities.GetDimensions(entCount, _);
    for(uint i = 0; i < entCount; i++)
    {
        Entity entity = Entities[i];
        if(length(entity.Position.xy - world) < .01)
        {
            cur += 1 * _Time.w;// entity.Energy;
        }
    }

    Result[id.xy] = cur;
}