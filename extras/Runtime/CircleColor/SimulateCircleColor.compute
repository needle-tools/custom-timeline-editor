#pragma kernel CSMain

struct Circle
{
    float3 Position;
    float Radius;
};

float2 WorldScale;
float4 _Time;
RWStructuredBuffer<Circle> Circles; 
RWTexture2D<float4> Result;
RWStructuredBuffer<float> Append;

struct ColorDot
{
    float3 Position;
    float4 Color;
    float Weight;
};

RWStructuredBuffer<ColorDot> Dots;

const uint2 neighbors[] = {
    uint2(-1,0),
    uint2(1,0),
    uint2(0,1),
    uint2(0,-1),
    uint2(-1,1),
    uint2(1,1),
    uint2(-1,1),
    uint2(-1,-1)
};
void SampleNeighbors(uint2 pixel, out float4 col)
{
    col = 0;
    for(int i = 0; i < 4; i++)
    {
        const uint2 neighborPixel = pixel + neighbors[i];
        const float4 neighborColor = Result[neighborPixel*3];
        // const float thres = 0.001;
        // if(neighborColor.r > thres || neighborColor.g > thres || neighborColor.b > thres)
        {
            col += neighborColor;
        }
    }
}

[numthreads(8,1,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height; 
    Result.GetDimensions(width, height);
    float2 uv = id.xy/float2(width,height);
    // uv.x += _Time.x * TimeFactor + MyField;
    // uv.y += OffsetY;
    // uv %= 1;
    float4 cur = Result[id.xy];
    float4 res = cur;// float4(uv.x,uv.y,0,1);
    float2 world = (uv - .5) * WorldScale;  

    uint circleCount, _;
    Circles.GetDimensions(circleCount, _);
    bool inCircle = false;
    for(int i = 0; i < circleCount; i++)
    {
        Circle circle = Circles[i];
        float2 cwp = circle.Position.xy;
        float dist = length(cwp - world);
        if(dist < circle.Radius)
        {
            inCircle = true;
            // res = 1;
        }
        // res.z += 1 * circle.Radius / circleCount;
    }

    if(inCircle)
    {
        uint dotsCount;
        Dots.GetDimensions(dotsCount, _);
        ColorDot closest = (ColorDot)0; 
        float closestDistance = 9999;
        bool foundClosest = false;
        for(int i = 0; i < dotsCount; i++)
        {
            ColorDot dot = Dots[i];
            const float2 cwp = dot.Position.xy;
            const float dist = length(cwp - world);
            if(dist < closestDistance)
            {
                foundClosest = true;
                closestDistance = dist;
                closest = dot;
            }
        }

        if(foundClosest)
        {
            // float factor = closest.Weight / dotsCount;
            // factor /= closestDistance; 
            res = (closest.Color - (closestDistance * closest.Weight));
        }
    }

    const float thres = 0.0000001;
    if(cur.r > thres || cur.g > thres || cur.b > thres)
    {
        float4 col;
        SampleNeighbors(id.xy, col);
        res = lerp(res, cur + saturate(col), _Time.w); 
    }
    
    // float4 cur = Result[id.xy];
    Result[id.xy] = lerp(cur, res, _Time.w * 22);
    Result[id.xy] = lerp(Result[id.xy], 0, _Time.w*3);
}
